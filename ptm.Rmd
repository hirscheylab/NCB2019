---
title: "Nat. Chem. Bio (2019)"
output:
  pdf_document:
    toc: TRUE
---

This is an [R Markdown](http://rmarkdown.rstudio.com) notebook accompanying the invited review on reactive carbon species, protein modifications, and carbon stress. When you execute code within the notebook, the results appear beneath the code and Figures will be save to the working directory. 

##Load libraries
```{r load_block, warning=FALSE, echo=TRUE}
library(tidyverse)
library(janitor)
library(viridis)
library(XML)
library(data.table)
library(igraph)
library(ggraph)
library(rmarkdown)
library(beepr) #long analysis; get some coffee, and comeback when ready

#clear environment
rm(list=ls()) 

#print Session information for provenance and reproducibility
utils:::print.sessionInfo(sessionInfo()[-7]) 
#You can remove an item from sessionInfo(), which is a list with a class attribute, by printing the resulting object omitting one of the list items (omitted list of packages installed, but not loaded)

#Set theme
theme_set(theme_light())
```

##Figure 1
Overall goal is to quanitfy known landscape of protein amino acids. Chose to get data from Uniprot, as a comprehensive and validated resouce containing data for human proteins. 
```{r fig1}
ptm_raw <- read_tsv("https://www.uniprot.org/docs/ptmlist.txt", col_names = FALSE, skip = 48) 
#skip 48 first lines which contain data file dictionary

#URL points to a datafile, to increase reproducibility; datafile is also downloaded 12/21/2018 and saved in working data directory in case URL link breaks

#make working df
ptm <- ptm_raw %>% 
  separate(X1, c("key", "value"), sep = 3) %>% 
  mutate(id = if_else(grepl("ID", key), value, NA_character_)) %>% #must call NA_char so that fill fxn works
  fill(id) #need fill fxn to populate ids across all observations, so that spread can work

#clean more
ptm$key <- str_trim(ptm$key, side = "right") #use stringr pkg to remove white space *janitor works on colnames only

#drop rows, duplicate rows are causing problems with spread, and don't need them
ptm <- ptm %>% 
  filter(!key %in% c("//", "TR", "DR", "---"))
  
#This is code I used to ensure that there were no duplicates
#ptm <- ptm %>%
#  unite(key_id, c("key", "id"), sep = "_", remove = FALSE)
#ptm_dup <- get_dupes(ptm, key_id)
#I check the ptm_dup df and made to sure to drop the keys that had more than one entry (immediate preceeding code chunk)

#spread data
ptm <- ptm %>% 
  spread(key, value) #not clever names, but appropriate

#gives a tibble of 645 observations, therefore 645 unique PTMs

#double check to see no duplicates
#get_dupes(ptm, id)

#more cleaning steps
ptm$MM <- as.numeric(ptm$MM)
ptm$MA <- as.numeric(ptm$MA)
ptm$KW <- str_replace(ptm$KW, "\\.", "") #need two \\ to mean literal "."
ptm$KW <- as.factor(ptm$KW)
ptm$FT <- str_trim(ptm$FT, side = "left") #use stringr pkg to remove white space
ptm$TG <- str_trim(ptm$TG, side = "left")
ptm$TG <- str_replace(ptm$TG, "\\.", "") #need two \\ to mean literal "."
ptm$KW <- fct_explicit_na(ptm$KW, na_level = "Other") #get rid of NAs in KW by making a factor
ptm <- ptm %>% select(-Cop, -Dis) #remove copyright and distribution columns

#a little bit of eda
count(ptm, FT, sort = TRUE)
#should I include crosslinks? Or just modifications?

ptm %>%
  filter(!FT == "CROSSLNK") %>% #omit AA cross links only
  summarize(n = n())
#This code snippet give me the total number of unique modifications, with CROSSLINK removed; total is 498. But I know the list doens't include 3 recently published modifications discovered by our group, plus a few others by YMZ (considering this a lag in DB updating), so OK to conclude over 500.

count(ptm, KW, sort = TRUE) #number of modifications by keyword
#a lot of glycoproteins!

#ptm %>%
#  filter(FT == "MOD_RES") %>% #include only modified AAs, no cross links, no lipids, no glycoproteins?
#  count(TG, sort = TRUE) %>% #target (TG) is exactly what I need
#  mutate(TG = fct_reorder(TG, n)) %>% 
#  ggplot(aes(TG, n)) +
#  geom_col() +
#  coord_flip() +
#  labs(x = "") + 
#  expand_limits(y = 40)
#commented this out because it only includes modified AAs; not sure if this is useful

ptm %>%
  filter(!FT == "CROSSLNK") %>% #omit AA cross links only
  count(TG, sort = TRUE)

ptm %>%
  filter(!FT == "CROSSLNK") %>% #omit AA cross links only
  count(TG, FT, sort = TRUE) %>% #target (TG) is exactly what I need
  mutate(TG = fct_reorder2(TG, FT, n, .desc = FALSE)) %>% 
  ggplot(aes(TG, n, fill = FT)) +
  geom_col(color = "black") +
  coord_flip() +
  #labs(x = "", title = "Distribution of Modifications Across Amino Acids", caption = "Plot by @matthewhirschey | Data from @Uniprot") + 
  labs(x = "", y = "Count") +
  expand_limits(y = 80) +
  scale_fill_viridis(discrete = TRUE, direction = -1, option = "viridis", labels = c("Carbohydrate", "Lipid", "All Other"), name = "Modification Type") +
  NULL

#save plot
ggsave("output/fig1.pdf", plot = last_plot(), dpi = 600)
```

##Figure 2
Goal is to determine how these modifications are distributed; thought it'd be interesting to visualize by average added mass (MA) to a protein, with several small changes in molecular mass, with some very large additions of mass
```{r fig2}
ptm %>%
  filter(!FT == "CROSSLNK") %>% #omit AA cross links only
  ggplot(aes(x = MA, fill = FT)) +
  geom_dotplot(method = "dotdensity", stackgroups = TRUE, binpositions = "all", binwidth = 20, dotsize = 1.05) + #empircally determined bin width + dot size ;]
  labs(x = "Average Mass Appended (Da)", y = "Count") +
  scale_fill_viridis(discrete = TRUE, direction = -1, option = "viridis", labels = c("Carbohydrate", "Lipid", "All Other"), name = "Modification Type")+
  scale_x_continuous(breaks = c(0,100,200,300,400,500,600,700,800,900,1000), limits = c(0,1000)) +
  scale_y_continuous(breaks = c(0,10,20,30,40,50,60,70), limits = c(0,70)) + #manually scale y because of geom_dotplot limitations
  NULL

#save plot
ggsave("output/fig2.pdf", plot = last_plot(), width = 5, height = 5, dpi = 600)

#the reason some average masses (MA) are so abundant is because you find the same modifications across several AAs, thereby weighting some more
#NB several glycans and lipids are variable masses, and therefore are entered as NA, so not reflected in the graph

ptm %>%
  filter(!FT == "CROSSLNK") %>% #omit AA cross links only
  count(KW, sort = TRUE)
```

###Lysine Analysis
In this code chunk, the goal is to count and summarize lysine modifications.
```{r lysine}
ptm %>% 
  filter(!FT == "CROSSLNK") %>% #omit AA cross links only
  filter(TG == "Lysine") %>% 
  count(ID, sort = TRUE)

#code chunk to make a tibble that is easy to view all attributes; no need to save as an object in environment
ptm %>% 
  filter(!FT == "CROSSLNK") %>% #omit AA cross links only
  filter(TG == "Lysine") %>% 
  arrange(MA) #sorts by mass, low to high
```

##Figure 3
In this figure, the goal is to determine how many acyl-CoA species have been measured
```{r import_fig3, eval=FALSE, include=FALSE}
Import metabolite data from HMDB (http://www.hmdb.ca/downloads); all metabolites http://www.hmdb.ca/system/downloads/current/hmdb_metabolites.zip

# Parse the XML files
proteins_raw <- xmlToDataFrame("data/hmdb_proteins.xml")
metabolites_raw <- xmlToDataFrame("data/hmdb_metabolites.xml")

save (temp) because extracting XML took a long time for a 4GB XML file!
save(proteins_raw, file = "data/proteins_raw.Rda")
save(metabolites_raw, file = "data/metabolites_raw.Rda")

#Commented out parsing and saving code, but then set this code chunk to eval/include = FALSE, so re-running the entire code fresh will simply skip this chunk, and load the raw data files in the next chunk as a df

```

```{r reload_fig3}
#reload
load("data/proteins_raw.Rda")
load("data/metabolites_raw.Rda")
```

```{r clean_fig3}
#as.X
proteins_raw <- as_tibble(proteins_raw)
metabolites_raw <- as_tibble(metabolites_raw)
metabolites_raw$average_molecular_weight <- as.numeric(metabolites_raw$average_molecular_weight)

#clean
metabolites <- metabolites_raw %>%
  select(one_of("accession", "name", "average_molecular_weight", "chemical_formula", "smiles", "normal_concentrations")) %>% 
  clean_names() %>% 
  remove_empty("rows") 
```

```{r fig3}
#count CoAs
CoA <- metabolites %>% 
  filter(str_detect(name, "CoA")) %>% 
  mutate(average_molecular_weight_noCoA = round(average_molecular_weight - 767.534, 2)) %>%  #substract weight of CoA for appended mass
  arrange(average_molecular_weight_noCoA)

CoA <- CoA %>% #number of carbons
  mutate(carbon_num = str_extract(chemical_formula, "C\\d+")) %>% #extract C then digit, then one or more
  mutate(carbon_num = str_extract(carbon_num, "\\d+")) %>% #to extract digit only
  mutate(carbon_num = as.numeric(carbon_num)) %>% #numeric, to do substraction next
  mutate(carbon_num_acyl = carbon_num - 21) %>% #remove number of carbons in CoA alone, to get acyls
  slice(-1:-6) %>%  #typos in the dataset
  arrange(carbon_num_acyl) %>% 
  mutate (type = "CoA")

CoA <- CoA %>% #number of oxygens
  mutate(o2_num = str_extract(chemical_formula, "O\\d+")) %>% #extract C then digit, then one or more
  mutate(o2_num = str_extract(o2_num, "\\d+")) %>% #to extract digit only
  mutate(o2_num = as.numeric(o2_num)) %>% #numeric, to do substraction next
  mutate(o2_num_acyl = o2_num - 16) %>% #remove number of oxygens in CoA alone, to get acyls
  slice(-1) #remove dephosphoCoA

CoA <- CoA %>%
  separate(smiles, into = c("smiles1", "smiles2"), sep = "S", remove = FALSE, extra = "merge") #split smiles code on the Sulfur(S); needed to split this from the next code chunk, so it runs first; if not, then throws an error that 'smiles1' does not exist (length is zero)
#https://en.wikipedia.org/wiki/Simplified_molecular-input_line-entry_system

CoA <- CoA %>%
  mutate(smiles_acyl = if_else(str_detect(smiles1, "P"), smiles2, smiles1)) #this is the code that pulls the 'acyl' from the split smiles data, and discards the CoA, becuase it contains the phosphate; this will allow me to look only at the possible protein appendage.

CoA <- CoA %>%
  mutate(acyl_description = if_else(str_detect(smiles_acyl, "\\(O\\)\\=O"), "Carboxyl", 
                                    if_else(str_detect(smiles_acyl, "CO"), "Hydroxyl", 
                                    if_else(str_detect(smiles_acyl, "C\\(O\\)C"), "Hydroxyl",
                                    if_else(str_detect(smiles_acyl, "C\\=C"), "Methylene",   
                                    if_else(str_detect(smiles_acyl, "C\\(\\=C\\)"), "Methylene",  
                                    if_else(str_detect(smiles_acyl, "CC\\=O"), "Aldehyde", #hardcode aldehyde
                                    if_else(str_detect(smiles_acyl, "C\\=O"), "Straight", #hardcode formyl        
                                    if_else(str_detect(smiles_acyl, "C\\(C\\)"), "Branched",        
                                    if_else(str_detect(smiles_acyl, "CCC"), "Straight", 
                                    if_else(str_detect(smiles_acyl, "CC\\(\\=O\\)"), "Straight", #hardcode acetyl         
                                        "Other")))))))))))
         
CoA %>%
  filter(str_detect(smiles_acyl, "N")) %>% #looking
  count(smiles_acyl, sort = TRUE)

CoA %>%
  count(average_molecular_weight, sort = TRUE) #code chunk to count acyl-CoAs, both total and discrete Molecular Weights

ggplot(CoA) +
  geom_bar(aes(x = carbon_num_acyl, fill = acyl_description), color = "black", width = 0.8) +
  labs(x = "Acyl-CoA Chain Length (# of carbons)", y = "Count") +
  expand_limits(y = 40) +
  scale_fill_viridis(discrete = TRUE, direction = -1, option = "magma", name = "Acyl Class") +
  scale_x_continuous(breaks = c(0,2,4,6,8,10,12,14,16,18,20,22,24,26,28), limits = c(0,28)) + 
  NULL

#save plot
ggsave("output/fig3.pdf", plot = last_plot(), width = 5, height = 5, dpi = 600)

```
###Acyl-phosphate Analysis
Code chunk to count acyl-phosphates. 10 total counted, although strangely two are listed at 266 Da. Same or different?
```{r acyl_phosphates}
phosphate <- metabolites %>% 
  filter(str_detect(smiles, "C\\(=O\\)OP")) %>% #regex the smiles code for carbonyl-phosphate bond
  arrange(average_molecular_weight) %>% 
  mutate (type = "Acyl Phosphate") %>% #duplicate entry!
  mutate(pre_post = if_else(str_detect(smiles, "C\\(=O\\)OP"), "pre", "post")) %>% 
  separate(smiles, into = c("pre_smiles", "post_smiles"), sep = "P", remove = FALSE, extra = "merge") %>%  #merge is to prevent discarding data
  mutate(added_carbons = if_else(grepl("pre", pre_post), str_count(pre_smiles, "C"), str_count(post_smiles, "C")))

phosphate %>%
  count(average_molecular_weight, sort = TRUE) #code chunk to count acyl-CoAs, both total and discrete Molecular Weights

```

###Cysteine Analysis
In this code chunk, the goal is to count and summarize cysteine modifications. Counted 57 (as of Feb 2019), however does not include 3 published modifiations: succination, 2,3-dicarboxylpropylation (i.e. itaconylation), or s-acetylation, so OK to conclude 60, at least.
```{r cysteine}
ptm %>% 
  filter(!FT == "CROSSLNK") %>% #omit AA cross links only
  filter(TG == "Cysteine") %>% 
  count(ID, sort = TRUE)

#code chunk to make a tibble that is easy to view all attributes; no need to save as an object in environment
ptm %>% 
  filter(!FT == "CROSSLNK") %>% #omit AA cross links only
  filter(TG == "Cysteine") %>% 
  arrange(MA) #sorts by mass, low to high
```
###Serine Analysis
In this code chunk, the goal is to count and summarize serine modifications. Counted 70 (as of Feb 2019). 
```{r serine}
ptm %>% 
  filter(!FT == "CROSSLNK") %>% #omit AA cross links only
  filter(TG == "Serine") %>% 
  count(ID, sort = TRUE)

ptm %>% 
  filter(!FT == "CROSSLNK") %>% #omit AA cross links only
  filter(TG == "Threonine") %>% 
  count(ID, sort = TRUE)

ptm %>% 
  filter(!FT == "CROSSLNK") %>% #omit AA cross links only
  filter(TG == "Tyrosine") %>% 
  count(ID, sort = TRUE)

ptm %>% 
  filter(!FT == "CROSSLNK") %>% #omit AA cross links only
  filter(TG == "Serine") %>% 
  filter(str_detect(CF, "P")) %>% 
  count(ID, sort = TRUE)
#13 serine modifications contain phosphate (12 carbon-phosphate, 1 phosphate only)

#code chunk to make a tibble that is easy to view all attributes; no need to save as an object in environment
ptm %>% 
  filter(!FT == "CROSSLNK") %>% #omit AA cross links only
  filter(TG == "Serine") %>% 
  arrange(MA) #sorts by mass, low to high
```

###Phenylalanine Analysis
In this code chunk, the goal is to count and summarize phenylalanine modifications. Counted 5 (as of Feb 2019); 1?
```{r phenylalanine}
ptm %>% 
  filter(!FT == "CROSSLNK") %>% #omit AA cross links only
  filter(TG == "Phenylalanine") %>% 
  arrange(MA) #sorts by mass, low to high
```

###Protein Backbone Analysis
In this code chunk, the goal is to count and summarize backbone modifications. First look at backbone alone; next look at the part of the protein where these are ascribed; then look at distribution of all backbone modifications on amino acids (glycine is the most); but, these are all n- or c-term modifications; if you look at protien core modifications, these are all serine/threonine/tyrosine and cysteine.
```{r backbone}
ptm %>% 
  filter(!FT == "CROSSLNK") %>% #omit AA cross links only
  filter(str_detect(PA, "backbone")) %>% 
  arrange(MA) #sorts by mass, low to high

ptm %>% 
  filter(!FT == "CROSSLNK") %>% #omit AA cross links only
  filter(str_detect(PA, "backbone")) %>% 
  count(PA, sort = TRUE)

ptm %>% 
  filter(!FT == "CROSSLNK") %>% #omit AA cross links only
  filter(str_detect(PA, "backbone")) %>% 
  count(PP, sort = TRUE)

ptm %>% 
  filter(!FT == "CROSSLNK") %>% #omit AA cross links only
  filter(str_detect(PA, "backbone")) %>% 
  count(TG, sort = TRUE)

ptm %>% 
  filter(!FT == "CROSSLNK") %>% #omit AA cross links only
  filter(str_detect(PA, "backbone")) %>% 
  filter(TG == "Glycine")

ptm %>% 
  filter(!FT == "CROSSLNK") %>% #omit AA cross links only
  filter(str_detect(PA, "backbone")) %>% 
  filter(str_detect(PP, "core")) %>% 
  count(TG, sort = TRUE)

ptm %>% 
  filter(!FT == "CROSSLNK") %>% #omit AA cross links only
  filter(str_detect(PA, "backbone")) %>% 
  filter(str_detect(PP, "core")) %>% 
  arrange(TG)
```

##Figure 4
The goal in this figure is to build a network diagram of metabolites and proteins, and then determine (count?) how many reactive species are a nodes. This might be a way to look at connectedness of metabolites, and ask if reactive metabolites are more or less connected than non-reactive ones. To do this, I need a list of nodes (metabolites) and a list of edges (proteins), and the relationship between them.
```{r fig4_data}
#to restart network analysis, uncomment this next line of code
#rm(reaction, node, link, link_group, edge)
kegg_reaction_raw <- fread('http://rest.kegg.jp/list/reaction', header = FALSE, col.names = c("rid", "reaction"))
link <- fread('http://rest.kegg.jp/link/ko/reaction', header = FALSE, col.names = c("rid", "kid"))

reaction <- kegg_reaction_raw %>% 
  separate("reaction", c("k1","k2","k3", "kegg_reaction_defn"), sep = ";", fill = "left") %>% #no more than 4 commas, so separates into 4 columns, and fills left, which is key to put all reaction equations into far right column
  replace_na(list(k1 = "", k2 = "", k3 = "")) %>% #drops NAs for next 'unite' step, which is essentially paste
  unite("kegg_reaction_name", c("k1","k2","k3"), sep = ",", remove = TRUE) #unites temp k1-k3 columns, adds commas, and removes temp columns
  
reaction$kegg_reaction_name <- str_replace_all(reaction$kegg_reaction_name, "^,{1,3}", "") #string replace to get rid of preceeding(^) commas, selecting between 1-3 {1,3}

link_group <- link %>% #generate an object to left-join that counts the number of kids (KO kegg ids) with a single reaction (rid); this will be used to weight
  group_by(kid) %>%  
  summarize (weight = n())

link <- link %>% #this gives me number of times a reaction id is associated with a gene (to be weighted more)
  left_join(link_group, by = "kid")

reaction <- reaction %>% 
  left_join(link, by = "rid") 

reaction$weight <- reaction$weight %>% replace_na(0)

reaction <- reaction %>% 
  select(-kid) %>% 
  mutate(weight = weight + 1) #gives weights a minimum of 1

#split equations, then separate_rows to fill/permute
reaction <- reaction %>% 
  separate(kegg_reaction_defn, sep = "<=>", into = c("reactant", "product")) %>% 
  separate_rows(reactant, sep = " \\+ ") %>% 
  separate_rows(product, sep = " \\+ ")

#need this step so the regex for "n " doesn't trim metabolites
reaction$product <- trimws(reaction$product, which = "both") 
reaction$reactant <- trimws(reaction$reactant, which = "both")

#remove balance equation numbers
reaction$product <- str_remove(reaction$product, "\\d+ ")
reaction$reactant <- str_remove(reaction$reactant, "\\d+ ")
reaction$product <- str_remove(reaction$product, "^n ") #start of string
reaction$reactant <- str_remove(reaction$reactant, "^n ") #start of string
```

```{r fig4}
#temp code to work with small df for testing
#uncomment for test runs; comment out for final analysis
#reaction <- slice(reaction, 1:1000)

omit <- NA #code to replace commented out code below
#omit <- c("H2O", "Oxygen", "CO2", "H+", "Acceptor", "e-", "ATP", "ADP", "AMP", "Orthophosphate", "Diphosphate", "NAD+", "NADH", "NADP+", "NADPH", "CoA", "Ammonia", "UDP", "UTP", "UMP", "Hydrogen Peroxide", "Hydrogen peroxide", "Reduced acceptor", "CTP", "CDP", "CMP", "GDP", "GTP", "GMP", "FADH2", "FADH", "FAD", "S-Adenosyl-L-methionine", "S-Adenosyl-L-homocysteine", "[Reduced NADPH---hemoprotein reductase]", "[Oxidized NADPH---hemoprotein reductase]", "Reduced ferredoxin", "Oxidized ferredoxin", "UDP-glucose") 

#messy and biased. Need a way to look at carbon, or specific reactive bonds (append smiles data)? Or a better way to simplify?

#set-up df for network
node <- reaction %>% 
  select("reactant") %>% 
  rename(name = reactant)

node_temp <- reaction %>% 
  select("product") %>% 
  rename(name = product)

node <- bind_rows(node, node_temp) %>% 
  unique() %>% 
  filter(!(name %in% omit))

rm(node_temp) #remove temp object

edge <- reaction %>% 
  rename(from = product) %>% 
  filter(!(from %in% omit)) %>% 
  rename(to = reactant) %>% 
  filter(!(to %in% omit)) %>% 
  rename(edge_name = kegg_reaction_name) %>% 
  select(c("from", "to", "weight")) #eventually edge_name can be an edge attribute?

g <- graph_from_data_frame(edge, directed = FALSE, vertices = node)
g$name <- "Metabolic Network" #give network a name
V(g) # Explore the set of nodes/vertices
E(g) # Explore the set of ties/edges


#first graph: super messy, but then can add measures from g
ggraph(g, layout = "auto") + #"linear", circular = TRUE
  geom_edge_link(aes(alpha = weight)) + 
  geom_node_point() +
  theme_void()

#add centrality measures to nodes
node <- node %>% 
  mutate(degree = degree(g)) %>% #The degree of a vertex is the number of its adjacent edges.
  mutate(strength = strength(g)) %>% #Summing up the edge weights of the adjacent edges for each vertex (same as degree, if not weighted)
  mutate(betweenness = betweenness(g)) %>% #quantifies how often a node lies on the shortest path between other nodes (measure of ties)
  mutate(closeness = closeness(g)) %>% # how close a node is to all other nodes in the network in terms of shortest path distance
  arrange(desc(degree))

node <- node %>% #where my CoAs at?
  mutate(CoA = str_detect(name, "CoA"))

#assess distribution of degree & betweenness; color by CoAs
ggplot(node) +
  geom_point(aes(x = degree, y = strength, color = CoA)) +
  scale_x_log10() +
  scale_y_log10() +
  labs(x = "Degree of Node (# connections)", y = "Strength (weighted degree)") +
  scale_color_viridis(discrete = TRUE, direction = -1, option = "viridis", alpha = 0.5) +
  NULL

node %>% filter(CoA == TRUE) #look at acyl-CoAs as a group, to see strength/degrees

#assess distribution of acyl-CoA degree within whole group
ggplot(node) +
  geom_histogram(aes(x = log10(degree), fill = CoA)) +
  labs(x = "Strength of Node (log10 # connections)") +
  scale_fill_viridis(discrete = TRUE, direction = -1, option = "viridis") +
  NULL

node %>% 
  mutate(decile = ntile(strength, 10)) %>% 
  group_by(decile, CoA) %>% 
  summarize(n = n())
```

```{r fig4_network}
#Next goal is to find similarities within network; therefore, adjacency matrix as a mathematical representation of a network and use it to find metabolites with similar connection patterns
edge_swap <- edge %>%
  mutate(temp = to, to = from, from = temp) %>% 
  select(-temp)

# Bind edge and edge_swapped by row
edge_bind <- bind_rows(edge, edge_swap)

rm(edge_swap) #remove temp object

# Using ties_bound, plot to vs. from, filled by weight
ggplot(edge_bind, aes(x = from, y = to)) + 
  geom_raster(aes (fill = weight)) +  # Add a raster geom
  labs(x = "", y = "", fill = "Edge\nWeight") + # Label the color scale as "weight"
  scale_fill_viridis(discrete = FALSE, direction = -1, option = "viridis") +
  theme(panel.background = element_blank(),
        axis.text.x = element_blank(), 
        axis.text.y = element_blank()) +
  coord_equal() +
  NULL

# Using nodes, plot strength vs.degree
ggplot(node, aes(x = degree, y = strength)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE) # Add a smooth geom with linear regression method

cor(node$degree, node$strength) # Calculate the Pearson correlation coefficient 

#set-up adjacency matrix
adj_mat <- as_adjacency_matrix(g, attr = "weight", names = TRUE, sparse = igraph_opt("sparsematrices"))
adj_mat <- as.matrix(adj_mat)
# Compute the Pearson correlation matrix of adjacency matrix
S <- cor(adj_mat)
# Set the diagonal of S to 0
diag(S) <- 0
# Flatten S to be a vector
flat_S <- as.vector(S)

# Plot a histogram of similarities
hist(flat_S, xlab = "Similarity", main = "Histogram of Correlation Coeffecients")

# Next goal is to graph adjacency matrix to look for metabolic subnetworks
h <- graph_from_adjacency_matrix(S, mode = "undirected", weighted = TRUE)
sim_df <- igraph::as_data_frame(h, what = "edges")

# Convert sim_df to a tibble
sim_df <- as_tibble(sim_df)

# Check the results; weight here corresponds to correlation coeffs
sim_df %>% 
  arrange(desc(weight)) # Arrange by descending similarity

#Visualize similarity; the whole  network can be difficult to understand/visualize; one useful way to make it more comprehensible is to think about clusters of similar metabolites By filtering the similarity matrix, then converting it to a network, we can see how many groups the whole metabolic network contains.
sim_filtered <- sim_df %>% 
  filter(weight > 0.6) # Filter on similarity greater than 0.6

# Convert to an undirected graph and Plot with auto layout
filtered_network <- graph_from_data_frame(sim_filtered, directed = FALSE)

ggraph(filtered_network, layout = "auto") + 
  geom_edge_link(aes(color = weight)) +   #mapping edge transparency to similarity, so only similar metabolites are clustered together
  #scale_edge_color_viridis(discrete = FALSE, begin = 0, end = 1) + #discrete = FALSE, direction = -1, option = "viridis"
  geom_node_point() +
  #geom_node_text(aes(label = name), label.size = 0.01, repel = TRUE) +
  theme_void() +
  NULL
```

```{r fig4_hairball}
#final 'hairball' graph 
g <- graph_from_data_frame(edge, directed = FALSE, vertices = node)
ggraph(g, layout = "auto") +
  geom_edge_link(aes(alpha = weight), show.legend = FALSE) + 
  geom_node_point(aes(size = degree, alpha = 0.2), show.legend = FALSE) + #need to put graph here becuase it integrates degree calcs from first graph
  #geom_node_text(aes(label = name), label.size = 0.01, repel = TRUE) + #would love labels, but too many!
  theme_void() +
  NULL

#save plot
ggsave("output/fig4.pdf", plot = last_plot(), dpi = 600)

```

##Figure 5
In this figure, the goal is to determine how many reactive [human] metabolites there are and to determine how many are associated with PTMs
```{r fig5}
#count thioesters
thioester <- metabolites %>% 
  filter(str_detect(smiles, "C\\(=O\\)S") | str_detect(smiles, "SC\\(=O\\)")) %>% #regex the smiles code for thioesters at either orientation
  arrange(average_molecular_weight) %>% 
  mutate(type = "Thioester") %>% 
  mutate(pre_post = if_else(str_detect(smiles, "C\\(=O\\)S"), "pre", "post")) %>% 
  separate(smiles, into = c("pre_smiles", "post_smiles"), sep = "S", remove = FALSE, extra = "merge" ) %>%  #merge is to prevent discarding data "Expected 2 pieces. Additional pieces discarded in 26 rows"
  mutate(added_carbons = if_else(grepl("pre", pre_post), str_count(pre_smiles, "C"), str_count(post_smiles, "C"))) #entry errors
  
#because the smiles code has thioesters with orientations that could add carbon on either sides of the code, the first mutate adds a pre_post column to indicate which side will be added; then the separate will split at the thiol; then the last mutate will count the number of carbons in either the pre or post column, depending.

#these include all from CoA list, except "CoA-"
#anti_join(CoA, thioester, by = "name")
#semi_join(CoA, thioester, by = "name") leaves 355, which is one less than in the CoA df

#sum(str_count(thioester$smiles, "C\\(=O\\)S")) #346
#sum(str_count(thioester$smiles, "SC\\(=O\\)")) #80

#thioester$added_carbons <- as.factor(thioester$added_carbons)

#count aldehydes
aldehyde <- metabolites %>%
  filter(str_detect(name, "aldehyde")) %>% #str_detect for aldehydes give too many false positives
  arrange(average_molecular_weight) %>% 
  mutate(type = "Aldehyde") %>% 
  mutate(added_carbons = str_count(smiles, "C"))
  
#Merge thioesters, phosphates, aldehydes
carbon <- full_join(thioester, phosphate) %>% 
  full_join(aldehyde) %>% 
  arrange(average_molecular_weight) %>% 
  select(-c("smiles", "pre_smiles", "post_smiles", "pre_post", "normal_concentrations"))

ggplot(carbon) +
  geom_bar(aes(x = added_carbons, fill = type), color = "black", width = 0.8) +
  labs(x = "Theoretical Carbons Appended") +
  scale_fill_viridis(discrete = TRUE, direction = -1, option = "inferno", name = "Class") +
  NULL

#save plot
ggsave("output/fig5.pdf", plot = last_plot(), width = 5, height = 5, dpi = 600)

```


##Save final files
Code chunk to save files
```{r save}
write_delim(ptm, "output/ptm.csv", delim = ",", na = "")
write_delim(metabolites, "output/metabolites.csv", delim = ",", na = "")
write_delim(carbon, "output/reactive_carbon.csv", delim = ",", na = "")
beep(sound = 8) #because mario is awesome
```

```{r}
#rmarkdown::render("ptm.Rmd", "pdf_document", output_dir = "output/")
#keep getting error; b/c circular? Copy line above and run manually in Console.
```

